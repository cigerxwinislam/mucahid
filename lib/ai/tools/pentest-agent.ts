import { toVercelChatMessages } from '@/lib/ai/message-utils';
import { streamText } from 'ai';
import type { Sandbox } from '@e2b/code-interpreter';
import { pauseSandbox } from '@/lib/tools/e2b/sandbox';
import { createAgentTools } from '@/lib/ai/tools/agent';
import { myProvider } from '@/lib/ai/providers';
import { executeTerminalCommandWithConfig } from './agent/terminal-command-executor';
import {
  generateTitleFromUserMessage,
  handleFinalChatAndAssistantMessage,
} from '@/lib/ai/actions';
import type { ChatMetadata, LLMID, ModelParams, FileAttachment } from '@/types';
import { handleMessageAttachments } from '@/lib/ai/tools/agent/utils/file-db-utils';
import { DefaultSandboxManager } from './agent/utils/sandbox-manager';
import PostHogClient from '@/app/posthog';
import { writePentestFilesToSandbox } from './agent/utils/sandbox-utils';
import { v4 as uuidv4 } from 'uuid';
import type { Doc } from '@/convex/_generated/dataModel';

interface PentestAgentConfig {
  chat: Doc<'chats'> | null;
  messages: any[];
  modelParams: ModelParams;
  chatMetadata: ChatMetadata;
  profile: any;
  dataStream: any;
  abortSignal: AbortSignal;
  model: LLMID;
  userCountryCode: string | null;
  systemPrompt: string;
  originalMessages?: any[];
  pentestFiles?: Array<{ path: string; data: string }>;
  initialChatPromise: Promise<void>;
}

export async function executePentestAgent({
  config,
}: {
  config: PentestAgentConfig;
}) {
  const {
    chat,
    modelParams,
    chatMetadata,
    profile,
    dataStream,
    abortSignal,
    model,
    userCountryCode,
    systemPrompt,
    pentestFiles,
    initialChatPromise,
  } = config;
  let messages = config.messages;

  let sandbox: Sandbox | null = null;
  const userID = profile.user_id;
  // Track if port exposure tool was used
  let exposedPort = false;

  // Create sandbox manager
  const sandboxManager = new DefaultSandboxManager(
    userID,
    dataStream,
    (newSandbox) => {
      sandbox = newSandbox;
    },
    sandbox,
  );

  try {
    const posthog = PostHogClient();
    if (posthog) {
      posthog.capture({
        distinctId: userID,
        event: 'pentest_agent_executed',
      });
    }

    // Try to execute terminal command if confirmTerminalCommand is true
    if (modelParams.confirmTerminalCommand) {
      const result = await executeTerminalCommandWithConfig({
        userID,
        dataStream,
        sandboxManager,
        messages,
      });

      if (typeof result === 'string') return result;
      messages = result.messages;
    }

    let generatedTitle: string | undefined;
    let customFinishReason: string | null = null;
    let assistantMessage = '';
    const fileAttachments: FileAttachment[] = [];
    const assistantMessageId = uuidv4();
    let titleGenerationPromise: Promise<void> | null = null;

    // Create a wrapper for dataStream.writeData to capture content
    const originalWriteData = dataStream.writeData;
    dataStream.writeData = (data: any) => {
      if (data.type === 'text-delta' && data.content) {
        assistantMessage += data.content;
      } else if (
        data.type === 'file-attachment' &&
        Array.isArray(data.content)
      ) {
        fileAttachments.push(...data.content);
      }
      originalWriteData(data);
    };

    if (
      !modelParams.confirmTerminalCommand &&
      !modelParams.isContinuation &&
      !modelParams.isTerminalContinuation
    ) {
      // Write pentest files to sandbox if they exist
      await writePentestFilesToSandbox(
        sandboxManager,
        pentestFiles || [],
        dataStream,
      );
    }

    dataStream.writeData({
      messageId: assistantMessageId,
    });

    // Start title generation if needed
    if (chatMetadata.id && !chat) {
      titleGenerationPromise = (async () => {
        generatedTitle = await generateTitleFromUserMessage({
          messages,
          abortSignal,
        });
        dataStream.writeData({ chatTitle: generatedTitle });
      })();
    }

    const { fullStream, finishReason } = streamText({
      model: myProvider.languageModel('chat-model-agent'),
      system: systemPrompt,
      messages: toVercelChatMessages(messages, true),
      maxTokens: 4096,
      tools: createAgentTools({
        dataStream,
        sandbox,
        userID,
        setSandbox: sandboxManager.setSandbox.bind(sandboxManager),
        agentMode: modelParams.agentMode,
        sandboxManager,
        userCountryCode,
      }),
      maxSteps: 10,
      toolChoice: 'required',
      abortSignal,
      onChunk: async (chunk) => {
        if (chunk.chunk.type === 'tool-call') {
          dataStream.writeData({
            type: 'agent-status',
            content: 'thinking',
          });

          // Check if the expose port tool is being used
          if (
            chunk.chunk.toolName === 'deploy_expose_port' ||
            chunk.chunk.toolName === 'shell_background'
          ) {
            exposedPort = true;
          }
        }
      },
      onError: async (error) => {
        if (
          !(
            error instanceof Error &&
            error.name === 'AI_InvalidToolArgumentsError'
          )
        ) {
          console.error('[TerminalAgent] Stream Error:', error);
        }
      },
      onFinish: async ({ finishReason }: { finishReason: string }) => {
        if (finishReason === 'length') {
          dataStream.writeData({
            type: 'text-delta',
            content: `<pgptml>I was unable to complete this task because one of the steps required more input than my current token limit allows. To help me assist you more effectively, please consider dividing your request or the information provided into smaller, more manageable parts. This will ensure I can process each step thoroughly and deliver the best possible results.</pgptml>\n\n`,
          });
        }

        // Wait for both title generation and initial chat handling to complete
        await Promise.all([titleGenerationPromise, initialChatPromise]);

        finishReason =
          finishReason === 'tool-calls' ? 'terminal-calls' : finishReason;

        await handleFinalChatAndAssistantMessage({
          modelParams,
          chatMetadata,
          profile,
          model,
          chat,
          finishReason: customFinishReason ? customFinishReason : finishReason,
          title: generatedTitle,
          assistantMessage,
          fileAttachments,
          assistantMessageId,
        });
      },
    });

    // Handle stream
    let shouldStop = false;
    for await (const chunk of fullStream) {
      if (chunk.type === 'tool-call') {
        if (chunk.toolName === 'idle') {
          dataStream.writeData({ finishReason: 'idle' });
          customFinishReason = 'idle';
          shouldStop = true;
        } else if (chunk.toolName === 'message_ask_user') {
          dataStream.writeData({
            type: 'text-delta',
            content: chunk.args?.text,
          });

          // Handle attachments if provided
          if (chunk.args?.attachments) {
            await handleMessageAttachments({
              attachments: chunk.args.attachments,
              userID,
              dataStream,
              sandboxManager,
            });
          }

          dataStream.writeData({ finishReason: 'message_ask_user' });
          customFinishReason = 'message_ask_user';
          shouldStop = true;
        } else if (
          modelParams.agentMode === 'ask-every-time' &&
          chunk.toolName === 'shell_exec'
        ) {
          const { exec_dir, command } = chunk.args;
          dataStream.writeData({
            type: 'text-delta',
            content: `<terminal-command exec-dir="${exec_dir}">${command}</terminal-command>`,
          });
          dataStream.writeData({
            finishReason: 'terminal_command_ask_user',
          });
          customFinishReason = 'terminal_command_ask_user';
          shouldStop = true;
        }
      }
    }

    // Send finish reason if not already sent
    if (!shouldStop) {
      const originalFinishReason = await finishReason;
      dataStream.writeData({ finishReason: originalFinishReason });
    }

    return 'Terminal execution completed';
  } catch (error) {
    console.error('[TerminalAgent] Error:', {
      error: error instanceof Error ? error.message : 'Unknown error',
    });
    dataStream.writeData({
      type: 'error',
      content: 'An error occurred during terminal execution. Please try again.',
    });
    throw error;
  } finally {
    // Don't pause sandbox if we've exposed a port, to keep services running for additional time
    if (sandbox) {
      if (!exposedPort) {
        await pauseSandbox(sandbox);
      } else {
        // console.log('[TerminalAgent] Keeping sandbox active for exposed port');
      }
    }
  }
}
